import { Chat } from "../../Models/chat.model.js";
import { inngest } from "../../Config/inngest.js";
import { cleanTempFile } from "../../Utils/cleanTempFile.js";
import { parsePDF } from "../../Utils/parsePdf.js";

import {
  generateQuiz,
  generateTranscript,
} from "../../Services/ai.services.js";
import { downloadYoutubeMp3 } from "../../Utils/downloadYoutubeMp3.js";
import { NonRetriableError } from "inngest";

export const onCreateChat = inngest.createFunction(
  {
    id: "on-create-chat",
    retries: 2,
  },
  { event: "chat/create" },
  async ({ event, step }) => {
    const { chatId } = event.data;
    try {
      // Pipeline starts

      const chat = await step.run("get-chat-document-object", async () => {
        const chatDoc = await Chat.findById(chatId);
        chatDoc.status = "processing";
        await chatDoc.save();
        return chatDoc;
      });
      console.log("Chat Fetched succesfully ");

      if (!chat) {
        console.log("Can't find chat so its nonRetriableError");

        throw NonRetriableError;
      }

      if (chat.chatType === "pdf") {
        //Pipeline For pdf
        console.log("Inside pfd pipeline");

        await step.run("upload-to-cloudinary", async () => {
          //TODO
        });

        // Converts pdf to chunks and save to vector db :)
        await step.run("save-and-process-pdf", async () => {
          const { noOfChunksMade, totalPages } = await parsePDF({
            filePath: chat.localPath.pdf,
            chatId,
          });
          await Chat.findByIdAndUpdate(chatId, {
            pdfMetaData: {
              noOfChunksMade,
              totalPages,
            },
            status: "completed",
          });
        });

        console.log("Chat saved to database Ssuccessfully ");

        await step.run("clean-temp-pdf", async () => {
          await cleanTempFile(chat.localPath.pdf);
        });
        console.log("Removed temp pdf .");
      } else {
        //Pipeline For youtubeVideo
        console.log("Inside youtube video pipeline");

        const { filePath } = await step.run(
          "download-youtube-audio-mp3",
          async () => {
            return await downloadYoutubeMp3(chat.youtubeUrl);
          }
        );

        console.log("Extracted File Path : ", filePath);

        await step.run("update-youtubeMp3Path-and-status-to-db", async () => {
          await Quiz.findByIdAndUpdate(quizId, {
            youtubeMp3Path: filePath,
            status: "processing",
          });
        });

        console.log("Updated temp mp3 filePath to  database");

        const rawText = await step.run("generate-transcribe", async () => {
          return await generateTranscript(filePath);
        });

        console.log("Transcript generated succesfully from the mp3");

        const cleanText = await step.run("clean-rawText", async () => {
          return await cleanRawText(rawText);
        });

        console.log("Cleaning the Transcript generated succesfully ");
        //Call LLM to generate chat
        const quizQuestions = await step.run("generate-chat", async () => {
          return await generateQuiz({
            text: cleanText,
            difficulty: chat.difficulty,
          });
        });
        console.log(
          "Quiz questions generated by the LLM   : ",
          quizQuestions.questions
        );

        await step.run("save-quizQuestions-to-db", async () => {
          await Quiz.findByIdAndUpdate(quizId, {
            questions: quizQuestions.questions,
            generatedAt: Date.now(),
            status: "completed",
            youtubeMp3Path: undefined,
            totalQuestions: quizQuestions.questions.length,
          });
        });

        // await step.run('clean-temp-pdf', async () => {
        //   await cleanTempFile(filePath);
        // });

        // console.log('Temp audio file cleaned succesfully');
      }

      return { success: true };
    } catch (error) {
      console.error("Error in running the pipeline : ", error.message);

      //   const chat = await Quiz.findByIdAndUpdate(quizId, { status: 'failed' });

      //   try {
      //     if (chat.sourceType === 'pdf') {
      //       if (chat.pdfPath) {
      //         await cleanTempFile(chat.pdfPath);
      //       }
      //     } else {
      //       if (chat.youtubeMp3Path) {
      //         await cleanTempFile(chat.youtubeMp3Path);
      //       }
      //     }
      //   } catch (cleanupError) {
      //     console.error('Failed to clean temp file:', cleanupError.message);
      //   }
      //   return { success: false };
    }
  }
);
